// Clearance Radar Monitor - Phase 2 (Walmart)
// Goal: Run fast, never hang, and ALWAYS send a useful Discord message
// - Pulls Walmart "clearance" search page
// - Attempts multiple patterns to extract products
// - Sends top cheapest items found
// - If none found, sends a heartbeat message (so you know it ran)

const webhook = process.env.DISCORD_WEBHOOK_URL;

const WALMART_SEARCH_URL =
  "https://www.walmart.com/search?q=clearance&sort=price_low";

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

function safeJsonParse(s) {
  try {
    return JSON.parse(s);
  } catch {
    return null;
  }
}

function uniqBy(arr, keyFn) {
  const seen = new Set();
  const out = [];
  for (const item of arr) {
    const k = keyFn(item);
    if (!k || seen.has(k)) continue;
    seen.add(k);
    out.push(item);
  }
  return out;
}

function cleanText(s) {
  if (!s) return "";
  return String(s)
    .replace(/\\u002F/g, "/")
    .replace(/\s+/g, " ")
    .trim();
}

function asNumber(x) {
  const n = Number(x);
  return Number.isFinite(n) ? n : null;
}

async function fetchWithTimeout(url, ms) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), ms);

  try {
    const res = await fetch(url, {
      method: "GET",
      signal: controller.signal,
      headers: {
        // A basic UA helps reduce bot-block edge cases
        "User-Agent": "Mozilla/5.0 (GitHub Actions) ClearanceRadar/2.0",
        "Accept-Language": "en-US,en;q=0.9",
      },
    });

    const text = await res.text();
    return { ok: res.ok, status: res.status, text };
  } finally {
    clearTimeout(timeout);
  }
}

function extractProductsFromHtml(html) {
  const products = [];

  // Pattern A (your original-ish approach):
  // "name":"...".*?"price":{"price":12.34}.*?"canonicalUrl":"..."
  const regexA =
    /"name":"([^"]+?)".{0,500}?"price":\{"price":([0-9.]+)\}.{0,800}?"canonicalUrl":"([^"]+?)"/g;

  for (const m of html.matchAll(regexA)) {
    const name = cleanText(m[1]);
    const price = asNumber(m[2]);
    const canonicalUrl = cleanText(m[3]);
    if (!name || price === null || !canonicalUrl) continue;
    products.push({ name, price, canonicalUrl });
  }

  // Pattern B (alternate price nesting seen on some layouts)
  // "name":"...".*?"currentPrice":{"price":12.34}.*?"canonicalUrl":"..."
  const regexB =
    /"name":"([^"]+?)".{0,700}?"currentPrice":\{"price":([0-9.]+)\}.{0,900}?"canonicalUrl":"([^"]+?)"/g;

  for (const m of html.matchAll(regexB)) {
    const name = cleanText(m[1]);
    const price = asNumber(m[2]);
    const canonicalUrl = cleanText(m[3]);
    if (!name || price === null || !canonicalUrl) continue;
    products.push({ name, price, canonicalUrl });
  }

  // If we still got nothing, try to find any JSON blobs that contain canonicalUrl + price
  // (lightweight fallback)
  if (products.length === 0) {
    const regexC =
      /"canonicalUrl":"([^"]+?)".{0,600}?"name":"([^"]+?)".{0,800}?"price":\{"price":([0-9.]+)\}/g;
    for (const m of html.matchAll(regexC)) {
      const canonicalUrl = cleanText(m[1]);
      const name = cleanText(m[2]);
      const price = asNumber(m[3]);
      if (!name || price === null || !canonicalUrl) continue;
      products.push({ name, price, canonicalUrl });
    }
  }

  // Normalize URLs and de-dupe
  const normalized = products
    .map((p) => {
      let url = p.canonicalUrl;
      if (!url.startsWith("http")) {
        url = "https://www.walmart.com" + (url.startsWith("/") ? "" : "/") + url;
      }
      return { ...p, url };
    })
    .filter((p) => p.url.includes("walmart.com"));

  return uniqBy(normalized, (p) => p.url);
}

function formatDiscordMessage({ ok, status, found, top }) {
  const ts = new Date().toLocaleString();

  // Always send *something*
  if (!ok) {
    return (
      `âš ï¸ **Walmart Radar Run (Heartbeat)**\n` +
      `Time: ${ts}\n` +
      `Result: Fetch failed (HTTP ${status})\n` +
      `Link: ${WALMART_SEARCH_URL}\n\n` +
      `Tip: Walmart sometimes blocks/changes page formats. If this repeats, weâ€™ll switch to a more reliable endpoint.`
    );
  }

  if (found === 0) {
    return (
      `ğŸŸ¦ **Walmart Radar Run (Heartbeat)**\n` +
      `Time: ${ts}\n` +
      `Result: No parsable products found (page layout may have shifted)\n` +
      `Link: ${WALMART_SEARCH_URL}\n\n` +
      `Next: We can harden the parser or switch to a JSON-based source.`
    );
  }

  let msg =
    `ğŸ”¥ **Walmart Clearance Radar**\n` +
    `Time: ${ts}\n` +
    `Found: **${found}** products (showing cheapest ${top.length})\n` +
    `Source: ${WALMART_SEARCH_URL}\n\n`;

  for (const p of top) {
    msg += `â€¢ **$${p.price.toFixed(2)}** â€” ${p.name}\n${p.url}\n\n`;
  }

  return msg.trim();
}

async function postToDiscord(content) {
  const res = await fetch(webhook, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ content }),
  });

  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Discord webhook failed: ${res.status} ${text}`);
  }
}

async function run() {
  if (!webhook) {
    throw new Error("DISCORD_WEBHOOK_URL not found (GitHub secret missing).");
  }

  // Hard timeout guard: never let this job hang forever
  const HARD_EXIT_MS = 25000;
  const hardExit = setTimeout(() => {
    console.error("âŒ Hard timeout hit â€” forcing exit.");
    process.exit(1);
  }, HARD_EXIT_MS);

  try {
    const { ok, status, text } = await fetchWithTimeout(WALMART_SEARCH_URL, 15000);

    const products = ok ? extractProductsFromHtml(text) : [];
    const sorted = products
      .filter((p) => p.price !== null && p.price >= 0)
      .sort((a, b) => a.price - b.price);

    // Make it â€œusefulâ€ for reselling: focus on cheaper items to scan quickly
    const top = sorted.slice(0, 8);

    const message = formatDiscordMessage({
      ok,
      status,
      found: products.length,
      top,
    });

    await postToDiscord(message);

    console.log(`âœ… Posted to Discord. Found=${products.length}`);
  } finally {
    clearTimeout(hardExit);
  }

  // Always exit cleanly
  process.exit(0);
}

run().catch((err) => {
  console.error("âŒ", err.message || err);
  process.exit(1);
});
